---
published: true
title: [이진탐색] Hash + 이분탐색을 이용한 Solution
categories: 알고리즘 
tag: [algorithm, 프로그래머스, BinarySearch, Hash ] 
toc: true
author_profile: false 
---



### 6번. 쿼리를 자바코드로 구현하기 

---

##### 문제 : 순위 검색 (LEVEL 2)

* 지원자 정보 (data)

  : 지원자가 지원서에 입력한 4가지의 정보와 획득한 코딩테스트 점수 

  ; 개발 언어(cpp, java, python) , 직군(backend, frontend) , 경력 (junior, senior) , 소울푸드(chicken, pizza) , 코테점수 (1~ 100,000)

  --> 각 지원자별로 이 내용들로 하나의 문자열로 구성 (공백으로 구분 )

  --> 전체 지원자들의 각각의 정보를 배열로 구성 : String[] info

* 검색 조건 (query) 

​	: 개발팀이 요구하는 지원자 합격 역량 

​	; 각 조건들이 and 로 이어진 문자열 (공백 + and + 공백으로 구분 )

​	 ※ '-'는 고려하지 않겠다는 의미 

​	ex)  "cpp and - and senior and pizza 500"은 "cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?"를 의미

​	--> 이 조건들이 여러개 있을 때 각각의 조건들을 모아 저장한 배열 : String[] query



* 도출해야하는 답 

  : 배열에 저장된 조건 순서대로(String[] query) 지원자들을 검토했을 때 (String[] info)

  , 만족하는 지원자의 명수를 각각 도출 하고 그 값들을 요소 값들로 배열에 저장 

​	: int[] answer



---

##### 내 풀이 ❌

* 코딩 테스트 점수로 정렬되어있으면 탐색이 쉬울 듯 ? 

  * 이걸 어떻게 하냐 ... 

    일단 지원자들 조건 공백으로 쪼개서 (배열? ...?)

    정렬 기준 선언해야할 듯 ?

  => Step 1 

* 이중 FOR 문  : i --> 쿼리문 / j --> 지원자들   ; 각 쿼리문마다 지원자들 싹 검토 

  => 도출되는 값을 int 배열에 담기 

  * i번째 쿼리문 --> 지원자들 적용 방법 

    1. 쿼리문을 '공백 + and + 공백' 기준으로 쪼갠다 

    2. 코딩 점수 기준으로 큰 지원자들을 이진 탐색으로 찾고(index) 

       그 index부터 순차 탐색한다 

    3. 해당 단어들이 j번째 지원자 문자열에 포함되는지 확인한다. (and 연산으로)

  => Step 2 

```java
import java.util.* ;
public class 순위탐색 {
	public int[] solution(String[] info, String[] query) {

		// step 1 . 코딩테스트 점수 기준으로 정렬 
		Arrays.sort(info, new Comparator(){
			@Override
			public int compare(Object o1, Object o2) {

				String[] data1 = ((String)o1).split(" ") ; 
				String[] data2 = ((String)o2).split(" ") ; 
				int score1 = new Integer(data1[4] ) ; 
				int score2 = new Integer(data2[4] ) ; 

				return score1 >score2 ? 1 : (score1 == score2 ? 0 : -1) ;
			} // compare
		}); // sort 

		// step 2. 쿼리문으로 검색하기 
		int[] answer = {};
		
		for (int i = 0; i < query.length; i++) {
			String[] queryParams = query[i].split(" and ") ; 
			int index = Arrays.binarySearch(info , queryParams[4] ) ; 
			int count = 0 ; 
			for (int j = index ; j < info.length; j++) {
				String[] datas = info[j].split(" ") ; 
				
				boolean flag = false ; 
				for (int k = 0; k < queryParams.length; k++) {
					
					if(datas[k].contains(queryParams[k]) ||  queryParams[k] == "-" ) {
						flag = true ;
					}
				} // k 
				if(flag) {
					count++ ; 
				}
			} // j 
			answer[answer.length] = count ; 
		} // i 

		return answer;
	} // main 
} // class 

```







---

##### 해설 풀이 ✔

```java
import java.util.*;

class Solution {
    public int[] solution(String[] info, String[] query) {
        // 1. info를 기반으로 hashMap 만들기
        HashMap<String, ArrayList<Integer>> hashMap = new HashMap<>();
        
        for (String i : info) {
            String[] data = i.split(" ");
            String[] languages = { data[0], "-" };
            String[] jobs = { data[1], "-" };
            String[] exps = { data[2], "-" };
            String[] foods = { data[3], "-" };
            Integer value = Integer.parseInt(data[4]);
            for (String lang : languages)
                for (String job : jobs)
                    for (String exp : exps)
                        for (String food : foods) {
                            String[] keyData = { lang, job, exp, food };
                            String key = String.join(" ", keyData);
                            ArrayList<Integer> arr = hashMap.getOrDefault(key, new ArrayList<Integer>());

                            arr.add(value);
                            hashMap.put(key, arr);
                        }
        }

        // 2. 각 hashMap의 value를 오름차순 정렬하기
        for (ArrayList<Integer> scoreList : hashMap.values())
            scoreList.sort(null);

        // 3. query 조건에 맞는 지원자를 가져오기
        int[] answer = new int[query.length];
        int i = 0;
        for (String q : query) {
            String[] data = q.split(" and ");
            int target = Integer.parseInt(data[3].split(" ")[1]);
            data[3] = data[3].split(" ")[0];
            String key = String.join(" ", data);

            if (hashMap.containsKey(key)) {
                ArrayList<Integer> list = hashMap.get(key);
                // 4. lower-bound/하한선 찾기
                int left = 0;
                int right = list.size();
                while (left < right) {
                    int mid = (left + right) / 2;
                    if (list.get(mid) >= target)
                        right = mid;
                    else
                        left = mid + 1;
                }

                answer[i] = list.size() - left;
            }
            i++;
        }
        return answer;
    }
```

